**AllerGuide: функциональные требования, архитектура и основные функции**  
  
**Функциональные требования**  
	•	**Поиск блюд по названию:** Пользователь должен иметь возможность ввести название интересующего блюда (на родном или иностранном языке) и получить анализ его безопасности при пищевой аллергии. Приложение автоматически собирает несколько рецептов этого блюда из открытых источников (сайты рецептов, меню ресторанов и пр.) и подготавливает данные для анализа .  
	•	**Анализ ингредиентов с помощью NLP:** Система должна извлекать из каждого найденного рецепта список ингредиентов (с помощью парсинга текста и NLP) и нормализовать названия ингредиентов (например, приводить к единому виду, учету синонимов и локальных названий продуктов). Далее ингредиенты каждого рецепта сопоставляются с базой данных аллергенов. Для этого требуется **словарь соответствия** ингредиентов и аллергенов – перечень ключевых слов, указывающих на присутствие определенных аллергенов  . Например, система должна распознавать, что термины *“маскарпоне”* или *“сыворотка”* относятся к молочным продуктам, *“альбумин”* – к яйцу, *“тахини”* – к сезаму и т.д. Такой словарь должен охватывать как распространенные, так и менее очевидные названия ингредиентов, связанных с аллергенами (включая региональные названия и иностранные языки).  
	•	**Выявление аллергенов в рецептах:** После сопоставления ингредиентов с онтологией аллергенов система определяет, какие **возможные аллергены** содержатся в каждом рецепте. На основе этого агрегируется статистика: для каждого распространенного аллергена рассчитывается, в каком проценте найденных рецептов данного блюда он присутствует. Пользователю отображается эта процентная **оценка риска** по каждому аллергену. Например, для блюда *Pad Thai* может оказаться, что **арахис** содержится в ~82% рецептов из Таиланда (традиционный вариант) и лишь в ~10% рецептов веганских интерпретаций – это укажет на высокий риск для аллергиков на орехи в оригинальном рецепте . Статистика должна вычисляться для **каждого из главных пищевых аллергенов** (например, орехи, арахис, молоко, яйца, глютен, рыба, морепродукты, соя, кунжут и т.д.).  
	•	**Разбиение статистики по регионам/кухням:** Система должна учитывать, что рецепт одного и того же блюда может различаться в разных кухнях и регионах. Необходимо группировать собранные рецепты по странам или типам кухни и отображать отдельную статистику по аллергенам для этих групп. Пользователь увидит, в каких странах блюдо более безопасно для него. Например, % содержания аллергена в *пицце Маргарита* в Италии vs. вариациях в других странах. Разбиение может выполняться по домену сайта (например, рецепты с доменом .it считаются итальянскими) или по языку/геолокации источника, либо на основе явных указаний в данных рецепта.  
	•	**Выявление опасных ингредиентов:** Помимо процентов, пользователю выводится список **конкретных ингредиентов**, которые наиболее часто несут риск. То есть, какие именно компоненты блюда являются носителями потенциальных аллергенов. Например: для человека с аллергией на молоко для блюда *песто* будут указаны «сыр пармезан, пекорино» как источники молочного белка; для аллергии на орехи в *песто* – «кедровые орехи». Эти данные помогают пользователю знать, о чем именно спрашивать официанта или на какие слова обращать внимание в меню.  
	•	**Персонализация под аллергии пользователя:** Пользователь может указать свои конкретные аллергены (или диетические ограничения) в профиле приложения или при каждом поиске. Система должна учитывать эти настройки и **выделять на результатах именно те аллергены**, которые критичны для данного пользователя. Например, если у пользователя аллергия на морепродукты и арахис, то в результатах для *Pad Thai* соответствующие данные (наличие креветок, арахиса) будут помечены особым образом. Если обнаружено, что **хотя бы один рецепт** блюда содержит опасный для пользователя аллерген, приложение может выдавать предупреждение или совет по осторожности . При наличии профиля предпочтений возможен фильтр – например, рекомендовать только те варианты блюда или альтернативы, которые не содержат указанных аллергенов.  
	•	**Генерация подсказок для общения в ресторане:** Для выбранного блюда приложение предоставляет заранее заготовленные **фразы для общения с официантом** на локальном языке. Пользователь выбирает нужный язык (или приложение определяет его по стране/местоположению) – и получает короткую фразу, которая объясняет его аллергию и уточняет, безопасно ли данное блюдо. Примеры таких фраз: *“У меня аллергия на орехи. Это блюдо содержит арахис или приготовлено на арахисовом масле?”* – с переводом, например, на тайский или итальянский язык. Эти фразы должны быть сформулированы вежливо и понятно для носителей языка. Для генерации переводов и вариантов фраз может использоваться либо встроенный справочник, либо LLM-модель. Наличие таких **многоязычных “карточек”** поможет избежать непонимания – аналогичные печатные карточки для аллергиков уже рекомендуются профильными организациями .  
	•	**Советы по безопасным альтернативам:** Если анализ показывает, что блюдо в данном регионе высокорисковое, или содержит неустранимые для пользователя аллергены, система может предложить **альтернативные варианты**. Например, порекомендовать другое близкое по вкусу блюдо, но без опасных ингредиентов, либо посоветовать просить заменить/убрать определенный ингредиент. Такие советы могут генерироваться с помощью LLM, опираясь на знание кулинарии (например, посоветовать заказать *Фо без рыбы* вместо супа с рыбным соусом, или заменить коровье молоко на растительное в коктейле).  
	•	**Оценка уверенности и ссылки на источники:** Приложение должно показывать уровень доверия к предоставленным данным (например, **confidence score** либо количество источников, подтверждающих информацию). Кроме того, для прозрачности каждому факту должна сопутствовать **ссылка на исходный рецепт или источник** в интернете, откуда получены сведения. Пользователь сможет при желании перейти и самостоятельно проверить ингредиенты рецепта. Такое использование подхода Retrieval-Augmented Generation (RAG) гарантирует прозрачность: все советы подкреплены реальными данными .  
	•	**Ввод через фотографию:** Мобильное приложение должно позволять пользователю сделать фото меню или названия блюда. Система выполняет OCR (распознавание текста) на изображении, чтобы извлечь название блюда или прочитать состав из меню. Таким образом, в ресторане и на путешествии можно просто **навести камеру на меню**, и приложение автоматически переведет названия блюд, идентифицирует их и сразу подсветит потенциально опасные позиции . В идеале, приложение может поддерживать даже определение самого блюда по фотографии (фуд-детекция): например, пользователь фотографирует неизвестное блюдо, а система пытается распознать его тип (с помощью обученной CV-модели) и затем выдает по нему информацию об аллергенах. (Эта функция может быть экспериментальной на этапе MVP.)  
	•	**Многоязычная поддержка интерфейса:** Приложение должно поддерживать несколько языков UI, чтобы им могли пользоваться путешественники из разных стран. Язык вывода информации (описания, ингредиенты, проценты, предупреждения) – на языке пользователя. В то же время, при поиске блюда на иностранном языке, система должна сопоставить его с локальным названием (например, запрос *“карбонара”* или *“Carbonara”* должны приводить к одним и тем же данным).  
	•	**Мобильное и кроссплатформенное использование:** MVP планируется как мобильное приложение (Android/iOS), поэтому функциональность должна быть оптимизирована под смартфоны: быстрый отклик, возможность работы оффлайн для уже загруженной информации (например, сохраненные фразы или последние результаты), использование камеры, минимальный ввод с клавиатуры. При этом должен быть реализован бекенд (серверная часть), через API которого приложение получает результаты анализа. В перспективе, тот же бекенд может быть использован и для веб-портала или интеграций с партнерами (например, туристическими сервисами).  
  
**Нефункциональные требования**  
	•	**Производительность:** Приложение должно предоставлять результат запроса пользователя в считанные секунды. Несмотря на то, что требуется собрать и проанализировать данные из интернета, для MVP нужно стремиться к минимальной задержке. Возможно, стоит использовать кэширование популярных запросов (если пользователь повторно ищет одно и то же блюдо, данные можно брать из локального кеша без повторного скрейпинга). Обработка фотографий (OCR) также должна быть оптимизирована – например, осуществляться прямо на устройстве для небольшого текста, либо на сервере с использованием быстрых облачных функций.  
	•	**Масштабируемость:** Система должна быть способна обрабатывать растущее количество запросов и расширять базу поддерживаемых блюд. В случае успеха приложения, нагрузка может вырасти (много одновременных пользователей, запросы ко многим разным блюдам). Архитектура бекенда и скрейпинга должна быть горизонтально масштабируемой – например, возможность добавить больше обработчиков для сбора данных, распределить запросы по очереди. Также должна легко добавляться поддержка новых кухонь и языков без полного переработы системы.  
	•	**Точность и полнота данных:** От качества анализа ингредиентов напрямую зависит здоровье пользователей, поэтому **точность критически важна**. Система должна минимизировать как ложно-негативные результаты (когда аллерген не обнаружен, хотя он есть), так и ложно-позитивные (когда предупреждение выдано без причины, чтобы не ограничивать лишнего). Для этого база аллергенов должна постоянно актуализироваться и включать даже редкие синонимы ингредиентов. Необходимо внедрить процесс проверки данных (например, ручной аудит наиболее популярных блюд, отзывы от пользователей об ошибках). Также стоит указывать пользователю, что информация носит справочный характер, и при малейшем сомнении нужно перепроверить у персонала.  
	•	**Надежность и отказоустойчивость:** Приложение должно стабильно работать в различных условиях. Если какой-то внешний источник (сайт рецептов) недоступен или формат данных изменился, система должна **корректно обрабатывать ошибки** (например, пропускать недоступный источник, но выдавать результат на основе других, или возвращать сообщение об ошибке пользователю в понятной форме). Не должно быть падений приложения при плохом интернете или при нераспознанном фото – предусмотреть таймауты и понятные сообщения вроде *“Не удалось получить данные, попробуйте еще раз”*. Также важна работа **офлайн** для уже полученной информации: если пользователь открыл анализ блюда и потерял связь, он все равно должен просмотреть ранее загруженные данные.  
	•	**Безопасность и приватность:** Поскольку пользователи могут вводить информацию о своем здоровье (аллергии) и делать личные запросы, все данные профиля должны храниться безопасно (шифрование, соблюдение GDPR для европейских пользователей и т.д.). Передача данных (запросов, результатов) между мобильным приложением и сервером – по защищенному протоколу (HTTPS). Фотографии, которые пользователь отправляет для OCR, не должны сохраняться на сервере дольше необходимого времени обработки, и нигде не публиковаться. Кроме того, приложение не будет требовать лишних персональных данных – только минимум, нужный для работы (например, список аллергенов и предпочтительный язык).  
	•	**Удобство использования (UX):** Интерфейс должен быть интуитивно понятным и **прагматичным**, соответствуя основной цели – быстро дать понятный ответ, можно ли это съесть или нет. Информация должна отображаться **наглядно**: например, иконки аллергенов с процентами, цветовые обозначения (зелёный – безопасно, жёлтый – с осторожностью, красный – опасно), минималистичные пояснения. Не перегружать пользователя техническими деталями – проценты и простые фразы вместо длинных текстов. При этом, для заинтересованных, должна быть возможность «углубиться» – раскрыть список ингредиентов, посмотреть ссылки на рецепты. Особое внимание – локализации: все надписи, включая сгенерированные фразы, должны грамотно отображаться на выбранном языке (правильные переводы, учёт единиц измерения, валют и т.д. в зависимости от региона).  
	•	**Локализация и мультикультурность:** Приложение предназначено для использования по всему миру, поэтому должно корректно работать с разными языками и культурными контекстами. Это касается не только перевода интерфейса, но и работы NLP-моделей – они должны распознавать ингредиенты на разных языках (например, *“flour”*, *“farine”*, *“harina”* должны маппиться к одному понятию “пшеничная мука, глютен”). Также в учете риска по регионам стоит понимать региональные названия блюд (например, *“оливье”* vs *“Russian salad”* – система должна знать, что это одно и то же блюдо). Для генерации фраз на местном языке может понадобиться адаптация под культурные нормы общения (формальности, единицы измерения – например, унции vs граммы и т.п.).  
	•	**Прозрачность и объяснимость:** Очень важно завоевать доверие пользователей, поэтому все результаты должны быть объяснимы. Каждая рекомендация (например, предупреждение об аллергене) должна сопровождаться указанием, **почему** она сделана – например: “80% рецептов содержат соевый соус, который включает пшеницу (глютен)” или “Обнаружен ингредиент рыбный соус – источник рыбного аллергена”. Наличие ссылки на источник рецепта  или авторитетную базу данных придаст убедительности. Кроме того, можно отображать **оценку уверенности** системы: например, если найдено очень мало данных по блюду, об этом честно сообщается: “Данных мало, будьте осторожны”. Такой прозрачный подход поможет пользователю принимать информированные решения, а не слепо доверять приложению.  
	•	**Масштабирование функциональности и поддержка:** Архитектура должна быть спроектирована с расчетом на дальнейшее развитие. Например, возможность добавить **новые категории пользователей** (веганы, люди с непереносимостью лактозы – перекликается с аллергиками, но своя специфика), **новые типы аллергий** (скажем, менее распространенные, типа аллергию на определенные специи), интеграции с внешними сервисами (бронирование ресторанов, доставка еды с фильтром по аллергенам). Кодовая база должна быть модульной и тестируемой, чтобы новые функции внедрялись без регрессий. Также нужно предусмотреть систему сбора обратной связи (фидбэк от пользователей, оповещения об ошибочно распознанных ингредиентах и пр.) – это позволит постоянно улучшать качество. Документация API и внутренней логики тоже относится к нефункциональным требованиям, чтобы команда могла эффективно поддерживать и развивать проект.  

  
**Пример сценария запроса:** Пользователь в мобильном приложении вводит “Pad Thai” и указывает, что у него аллергия на арахис и моллюсков. Приложение отправляет запрос на бекенд. Бекенд обращается к модулю скрейпинга, который собирает, скажем, 15 рецептов Pad Thai (на тайском кулинарном сайте, на паре английских, на веган-блоге и т.д.). NLP-модуль парсит ингредиенты каждого: обнаруживает арахис, креветки, яйцо в большинстве тайских рецептов, веганский рецепт без них, но с тофу (соя). Аллергенная база сопоставляет: арахис -> аллергент “орехи”, креветки -> “ракообразные”, соевый соус -> “соя”, яйцо -> “яйца”. Модуль статистики считает: орехи в 12 из 15 рецептов (~80%), ракообразные в 10/15 (~67%), яйца в 8/15, соя в 3/15. Отдельно помечает, что 3 рецепта были помечены как “vegan” и ни в одном из них не было арахиса (0%) ни яиц (0%). Confidence высокий, т.к. источников >10. Эти данные передаются генератору. LLM формирует ответ на русском: “Pad Thai традиционно содержит арахис (примерно в 80% рецептов) и креветки (в ~65%). Вам, как аллергiku на арахис, стоит быть особенно внимательным: попросите приготовить без орехов. Фраза для официанта на тайском: …”. Также приложение отображает в UI инфографику: значок “орехи – 80%” (красным), “ракообразные – 65%” (желтым), “яйцо – 53%” (желтым), “соя – 20%” (зеленым), и галочку, что существует веган-вариант без этих аллергенов. Пользователь копирует фразу на тайском и показывает официанту; также, при желании, разворачивает список “ингредиенты, вызывающие опасения: crushed peanuts, peanut oil, shrimp, fish sauce (anchovy)” – которые были отмечены NLP. Все это реализовано сочетанием модулей, взаимодействующих как описано.  
  
Архитектура MVP, резюмируя, включает:  
**мобильное приложение**, **серверный API**, **веб-скрейпер**, **NLP/аллергенный анализатор**, **база знаний об аллергенах**, **LLM-сервис** для генерации объяснений/переводов, а также **вспомогательные сервисы** (OCR, перевод) по необходимости. Такая модульность позволяет в дальнейшем дорабатывать компоненты независимо: например, заменить алгоритм NLP на более совершенный или добавить новые источники данных без изменений в мобильном клиенте.  
  
**Архитектура MVP**  
  
**Общая схема:** архитектура основана на клиент-серверном подходе. Мобильное приложение служит интерфейсом для пользователя, а основная обработка происходит на серверной стороне (бекенде). Ниже описаны ключевые компоненты системы и их взаимодействие:  
	•	**Мобильный клиент (iOS/Android):** Приложение предоставляет UI для ввода данных (поисковая строка, выбор аллергии, съемка фото), отображает результаты анализа и позволяет пользователю взаимодействовать (напр. копировать переведенную фразу для официанта). Логика на клиенте минимальна – основная задача отправить запрос на сервер (через REST/GraphQL API) и красиво отобразить полученный ответ. Также приложение может выполнять предварительные задачи: например, использовать библиотеку OCR локально для распознавания текста на фото меню перед отправкой запроса, чтобы снизить нагрузку на сервер и ускорить отклик.  
	•	**API-шлюз и Backend-сервер:** На сервере располагается основной веб-сервис (например, Node.js, Python FastAPI или другой стек), который обрабатывает входящие запросы от приложения. Этот бекенд реализует следующие подкомпоненты (логически или физически):  
	•	**Модуль сбора данных (Web Scraping):** При поступлении запроса с названием блюда, этот компонент отвечает за автоматический поиск рецептов и описаний блюда в интернете. На MVP-этапе возможен вариант: обращаться к специализированному API (если такое доступно, напр. Spoonacular) или выполнять **веб-скрейпинг** через поисковик и парсинг HTML популярных сайтов рецептов. Модуль собирает N рецептов (например, 10-20 штук) по заданному блюду. Каждый рецепт должен включать список ингредиентов и, по возможности, указание на происхождение/кухню. Web Scraper должен быть достаточно гибким, чтобы работать с разными структурами сайтов (в MVP можно ограничиться парой-тройкой доминантных источников). Полученные данные передаются в следующий модуль. *(Примечание: чтобы ускорить ответы, можно реализовать **кэш** – например, хранить результаты парсинга по уже запрошенным блюдам в базе, чтобы повторно не собирать их с веба.)*  
	•	**NLP-модуль обработки ингредиентов:** Этот компонент на вход получает сырые списки ингредиентов из рецептов. Его задачи:  
	1.	Привести ингредиенты к стандартному виду (нормализация текста: убрать описания количества, привести к единственному числу, перевести при необходимости на базовый язык анализа, например, английский).  
	2.	Распознать ключевые слова, соответствующие аллергенам, используя заранее сформированную **онтологию аллергенов**. Онтология хранится в базе знаний и включает, например, список основных аллергенов и связанных с ними ингредиентов (включая синонимы, локальные названия). NLP-модуль по каждому ингредиенту определяет, к какому аллергену он относится, если относится. (Например, *“йогурт (молоко)” -> молоко; “тофу (соевые бобы)” -> соя; “тамари” -> соя; “миндальная мука” -> древесные орехи и т.д.).  
	3.	На основе этого прохода формируется список **найденных аллергенов для каждого рецепта**. Например, для рецепта Pad Thai из тайского сайта может получиться: арахис, креветки (ракообразные), яйца.  
	4.	Дополнительно, NLP-модуль может пытаться определить страну/регион рецепта, если это не сделано на этапе сбора. Методы: анализ языка ингредиентов (например, испанские слова -> вероятно рецепт из испаноязычной среды), или по URL домену, или по названиям блюд (наличие специфичных ингредиентов типа *“fish sauce”* указывает на ЮВА). Это нужно для разбиения статистики.  
	•	**База данных аллергенов и ингредиентов:** По сути, справочник/словарь, используемый NLP-модулем. Он может быть реализован в виде таблицы (CSV/SQL) или даже кода, содержащего словари. Например:  
	•	“Egg” allergen: [“egg”, “albumin”, “meringue”, …] – список слов, указывающих на яйца;  
	•	“Milk” allergen: [“milk”, “cream”, “whey”, “casein”, “cheese”, “масло сливочное”, …] и т.д.  
Словарь должен поддерживать множественные языки. Его наполнение – комбинирование общедоступных списков аллергенов (например, OpenFoodFacts, FDA, FALCPA) и экспертизы команды. MVP-вариант может охватить **топ-14 аллергентов** (по стандартам ЕС и США) и их синонимы. Данная база – **сердце системы**, именно на нее опирается точность анализа .  
	•	**Модуль статистики и риск-оценки:** Когда NLP обработал все рецепты блюда, наступает этап агрегирования. Этот компонент подсчитывает, сколько рецептов (и доля от общего числа) содержат каждый из известных аллергенов. Здесь же выполняется группировка по регионам: например, отдельно считать для группы “Таиланд” vs “вегетарианские/веган рецепты” vs “Западные интерпретации”. Логика группировки может быть задана вручную для некоторых популярных блюд (зная, что, скажем, *“оригинальный рецепт”* vs *“адаптированный”*), или автоматически на основе схожести ингредиентов. Результатом работы модуля является структура данных, содержащая по каждому аллергену процент рецептов с ним (глобально и по регионам), а также перечень конкретных ингредиентов-носителей (например, для арахиса – “арахисовое масло, дробленый арахис” обнаружены в X рецептах). Также вычисляется **score уверенности** – например, основанный на количестве рецептов (если рецептов <5, доверие низкое; если >20 из разных источников, доверие высокое), на однородности результатов (если все рецепты согласны, то уверенность выше). Этот score потом будет отображаться пользователю.  
	•	**Модуль генерации ответов (LLM + RAG):** Имея на руках структуру данных с результатами, система готовит человекочитаемый ответ. Для большей гибкости и многоязычности планируется использовать связку **Large Language Model с дополнением контекстом (RAG)**. Как это может работать:  
	•	Backend хранит набор шаблонов и инструкций для LLM (например: *“Пользователь говорит на русском, аллергия такая-то. Сгенерируй объяснение, какие риски у блюда, на русском, упомяни проценты, перечисли опасные ингредиенты, и предложи фразу для официанта на тайском языке.”*).  
	•	Затем к этой инструкции добавляются факты из базы (проценты, списки ингредиентов) как контекст. Например, топ-3 аллергена для блюда, их проценты, ключевые ингридиенты.  
	•	LLM (например, GPT-4 или open-source модель) получает этот prompt с данными и генерирует связный текст объяснения: *“В традиционных рецептах **Pad Thai** часто присутствует арахис (в 82% рецептов), поэтому будьте осторожны. Также нередко добавляют креветки (ракообразные) и яйца. В веган-версиях орехи встречаются реже (~10%). Рекомендуем спросить: «Содержится ли арахис в порции Pad Thai?» на тайском: …*”.  
	•	Для генерации перевода фраз на нужный язык LLM может использовать либо встроенные знания, либо подключаться к переводчику. В режиме MVP, возможно, хватит и статических заготовок фраз, но LLM облегчит масштабирование на десятки языков.  
	•	Важный момент: использование RAG означает, что LLM опирается только на релевантные **достоверные данные** (вытянутые рецепты, словари и пр.), а не “придумывает” от себя. Это снижает риск галлюцинаций и ошибок. В идеале, ссылки на источники или даже фрагменты рецептов могут вставляться LLM-ом в ответ или выдаваться структурированно через API для отображения.  
	•	Если LLM-сервис недоступен или тормозит, бекенд должен иметь упрощенный fallback: например, сформировать ответ на основе шаблонов программно (без красивых формулировок, но чтобы хоть что-то выдать быстро).  
	•	**База данных приложения:** Помимо базы знаний об аллергенаx, система, вероятно, будет иметь и хранилище для пользовательских данных (аккаунты, сохраненные аллергии, история запросов для офлайн-доступа). Для MVP это может быть облачная NoSQL или SQL база. Также база может хранить **кеш результатов анализа** по популярным блюдам (вычисленная статистика), чтобы не пересчитывать каждый раз заново.  
	•	**Интеграции внешних сервисов:** Некоторые функции могут полагаться на сторонние API:  
	•	Сервис OCR (если не на устройстве, то вызов облачного Vision API для распознавания текста с фото меню).  
	•	Геолокация или API стран – чтобы определить, в какой стране пользователь и автоматически подставить язык для фраз.  
	•	Переводчики – например, для получения шаблонных фраз на редких языках, если не хотим доверять этому полностью LLM.  
	•	Отправка аналитики/логов – сбор анонимной статистики использования, ошибок скрейпинга и т.д. (для разработчиков).  \

**Основные фишки приложения**  
  
**AllerGuide** предназначен сделать питание людей с аллергиями безопаснее по всему миру. Ниже перечислены ключевые особенности и преимущества этого приложения:  
	•	**Мгновенная оценка риска по аллергенам:** Просто введите название блюда – и приложение выдаст наглядную оценку, насколько оно безопасно. Вы сразу увидите, какой процент рецептов этого блюда содержит каждый из основных аллергенов (например, молоко, орехи, глютен и др.) в виде процентов и индикаторов. Это позволяет быстро понять, есть ли повод для беспокойства, еще до заказа блюда.  
	•	**Адаптация под местную кухню:** AllerGuide учитывает региональные различия. Вы узнаете, как состав блюда меняется от страны к стране. Например, традиционный рецепт может содержать опасный ингредиент, а локальная версия в другой стране – нет. Приложение покажет разбивку: для каждого региона или типа кухни – свои проценты аллергенов. Это особенно полезно в путешествиях, когда одно и то же название блюда может скрывать разный состав.  
	•	**“Подводные камни” в составе:** Приложение перечисляет конкретные **ингредиенты**, на которые стоит обратить внимание. Оно выделит названия продуктов в рецепте, которые являются носителями аллергенов (например, **“соевый соус (содержит пшеницу и сою)”**, **“марципан (миндаль)”**). Благодаря этому вы будете знать, какие слова искать в меню или спросить про них персонал, чтобы убедиться в безопасности блюда.  
	•	**Личные настройки аллергии:** AllerGuide можно настроить под свои потребности. Укажите, на что у вас аллергия или непереносимость – и приложение сфокусируется на этих аллергенах. Вся информация будет персонализирована: опасные для **вас** ингредиенты будут отмечены особо, а советы – более точными. Это избавляет от лишнего шума и делает рекомендации более релевантными.  
	•	**Разговорник для ресторана:** Одно из главных удобств – готовые **фразы-подсказки для общения с официантом**. Приложение сгенерирует короткое сообщение на языке той страны, где вы находитесь (или языка, которого требует ситуация), с информацией о вашей аллергии. Вам не нужно ломать голову над переводом – просто покажите или произнесите эту фразу. Например, находясь в Италии, можно предъявить записку: *“Ho un’allergia ai latticini. Questo piatto contiene formaggio o latte?”* (У меня аллергия на молочные продукты. Есть ли в этом блюде сыр или молоко?). Такие “карточки” значительно упрощают коммуникацию за границей и снижают риск недопонимания .  
	•	**Альтернативы и рекомендации:** Если выбранное блюдо оказалось рискованным, AllerGuide не оставит вас без решения. Приложение предложит безопасные **альтернативы** – например, другие блюда схожей кухни, но без опасных ингредиентов, или подскажет, как можно модифицировать блюдо (убрать топпинг, заменить гарнир и т.п.). Эти рекомендации помогут не чувствовать себя ограниченным – всегда найдется вариант попробовать местную еду без угрозы здоровью.  
	•	**Прозрачность и доверие к данным:** Каждая цифра и совет в приложении подкреплены реальными источниками. Вы можете нажать на любую оценку риска и увидеть, из каких рецептов она получена, вплоть до списка ингредиентов. AllerGuide не скрывает информацию “под капотом” – напротив, он дает вам инструменты самим убедиться в ее точности (через ссылки на рецепты, кулинарные статьи и т.д.). Кроме того, приложение показывает **уверенность анализа** – если данных мало или они противоречивые, вы узнаете об этом. Такой подход открытости позволяет пользователям чувствовать себя уверенно, принимая решение на основе приложения.  
	•	**Использование камеры для удобства:** В реальной ситуации, особенно в другой стране, набирать название блюда вручную может быть неудобно. AllerGuide предлагает функционал сканирования – просто наведите камеру смартфона на бумажное меню, и оно автоматически распознает названия блюд, переведет их (если нужно) и сразу выполнит анализ на аллергены. Буквально **пару тапов**, и вы уже знаете, какое блюдо из списка безопасно, а какое под вопросом . Это экономит время и избавляет от языкового барьера. Даже фотография самого блюда может помочь – приложение постарается определить, что на ней, по внешнему виду, и найти соответствующее блюдо в базе. Все ради того, чтобы вы могли **есть безопасно и без лишнего стресса**, куда бы ни отправились.  
	•	**Современные технологии под капотом:** Хотя для пользователя AllerGuide прост и понятен, внутри него работают сложные технологии – от интеллектуального веб-поиска рецептов до нейросетей обработки языка (NLP) и **генеративного ИИ**. Например, большие языковые модели помогают переводить и составлять вежливые обращения на разных языках, а алгоритмы машинного обучения – извлекать смысл из текстов рецептов. Эти инновации делают приложение гибким и умным: оно постоянно учится на новых данных, становится точнее с каждым запросом. Для пользователя же все это прозрачно – вы просто получаете нужную информацию в удобной форме.  
